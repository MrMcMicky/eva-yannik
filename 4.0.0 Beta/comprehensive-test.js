// Umfassender Test f√ºr Eva & Yannik Website v4.0.0
const puppeteer = require('puppeteer');
const fs = require('fs');

async function runComprehensiveTest() {
    console.log('üß™ Eva & Yannik Website v4.0.0 - Umfassender Test\n');
    console.log('üåê Testing: https://eva-yannik.assistent.my.id\n');
    
    const results = {
        passed: [],
        failed: [],
        warnings: []
    };
    
    const browser = await puppeteer.launch({
        headless: 'new',
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    try {
        const page = await browser.newPage();
        
        // Console-Nachrichten aufzeichnen
        const consoleLogs = [];
        page.on('console', msg => {
            consoleLogs.push({
                type: msg.type(),
                text: msg.text()
            });
        });
        
        // Fehler aufzeichnen
        const pageErrors = [];
        page.on('error', err => pageErrors.push(err.toString()));
        page.on('pageerror', err => pageErrors.push(err.toString()));
        
        // 1. Seite laden
        console.log('üìÑ 1. Lade Seite...');
        const startTime = Date.now();
        await page.goto('https://eva-yannik.assistent.my.id', { 
            waitUntil: 'networkidle2',
            timeout: 30000 
        });
        const loadTime = Date.now() - startTime;
        
        if (loadTime < 3000) {
            results.passed.push(`‚úÖ Seite in ${loadTime}ms geladen`);
        } else {
            results.warnings.push(`‚ö†Ô∏è Langsame Ladezeit: ${loadTime}ms`);
        }
        
        // 2. CSS und JavaScript pr√ºfen
        console.log('\nüé® 2. Pr√ºfe CSS und JavaScript...');
        
        const hasCSS = await page.evaluate(() => {
            return document.styleSheets.length > 0;
        });
        
        const jsModulesLoaded = await page.evaluate(() => {
            return {
                countdown: typeof CountdownTimer !== 'undefined',
                uiControls: typeof UIControls !== 'undefined',
                milestones: typeof MilestonesTracker !== 'undefined',
                splashScreen: typeof SplashScreen !== 'undefined'
            };
        });
        
        if (hasCSS) {
            results.passed.push('‚úÖ CSS erfolgreich geladen');
        } else {
            results.failed.push('‚ùå CSS nicht geladen');
        }
        
        Object.entries(jsModulesLoaded).forEach(([module, loaded]) => {
            if (loaded) {
                results.passed.push(`‚úÖ ${module} Modul geladen`);
            } else {
                results.failed.push(`‚ùå ${module} Modul fehlt`);
            }
        });
        
        // 3. Countdown Timer testen
        console.log('\n‚è∞ 3. Teste Countdown Timer...');
        
        const countdownWorking = await page.evaluate(() => {
            const days = document.getElementById('days');
            const initialValue = days ? days.textContent : '0';
            return new Promise(resolve => {
                setTimeout(() => {
                    const newValue = days ? days.textContent : '0';
                    resolve({
                        exists: !!days,
                        updating: initialValue !== newValue || parseInt(initialValue) > 0
                    });
                }, 1100);
            });
        });
        
        if (countdownWorking.exists && countdownWorking.updating) {
            results.passed.push('‚úÖ Countdown Timer l√§uft');
        } else if (countdownWorking.exists) {
            results.warnings.push('‚ö†Ô∏è Countdown existiert aber updated nicht');
        } else {
            results.failed.push('‚ùå Countdown Timer nicht gefunden');
        }
        
        // 4. Buttons testen
        console.log('\nüîò 4. Teste Navigation Buttons...');
        
        const buttons = [
            { id: 'newMenuButton', name: 'Menu' },
            { id: 'bibleButton', name: 'Bible' },
            { id: 'newSettingsButton', name: 'Settings' },
            { id: 'infoButton', name: 'Info' }
        ];
        
        for (const btn of buttons) {
            const buttonExists = await page.$(`#${btn.id}`);
            if (buttonExists) {
                results.passed.push(`‚úÖ ${btn.name} Button gefunden`);
                
                // Test click
                await page.click(`#${btn.id}`);
                await page.waitForTimeout(500);
                
                // Check if overlay opened
                const overlayActive = await page.evaluate(() => {
                    const overlays = document.querySelectorAll('.menu-overlay, .bible-overlay, .settings-overlay, .info-overlay');
                    return Array.from(overlays).some(o => o.classList.contains('active') || o.style.display !== 'none');
                });
                
                if (overlayActive) {
                    results.passed.push(`‚úÖ ${btn.name} Overlay √∂ffnet sich`);
                    
                    // Try to close with ESC
                    await page.keyboard.press('Escape');
                    await page.waitForTimeout(300);
                } else {
                    results.warnings.push(`‚ö†Ô∏è ${btn.name} Overlay √∂ffnet sich nicht`);
                }
            } else {
                results.failed.push(`‚ùå ${btn.name} Button nicht gefunden`);
            }
        }
        
        // 5. Responsive Design testen
        console.log('\nüì± 5. Teste Responsive Design...');
        
        const viewports = [
            { name: 'Mobile', width: 375, height: 667 },
            { name: 'Tablet', width: 768, height: 1024 },
            { name: 'Desktop', width: 1920, height: 1080 }
        ];
        
        for (const vp of viewports) {
            await page.setViewport({ width: vp.width, height: vp.height });
            await page.waitForTimeout(500);
            
            const hasOverflow = await page.evaluate(() => {
                return document.documentElement.scrollWidth > document.documentElement.clientWidth;
            });
            
            if (!hasOverflow) {
                results.passed.push(`‚úÖ ${vp.name} View - Kein horizontaler Overflow`);
            } else {
                results.failed.push(`‚ùå ${vp.name} View - Horizontaler Overflow erkannt`);
            }
            
            // Screenshot
            await page.screenshot({ 
                path: `screenshots/${vp.name.toLowerCase()}-test.png`,
                fullPage: true 
            });
        }
        
        // 6. Meilensteine pr√ºfen
        console.log('\nüèÜ 6. Teste Meilensteine...');
        
        const milestones = await page.evaluate(() => {
            const grid = document.querySelector('.milestones-grid');
            const items = grid ? grid.querySelectorAll('.milestone') : [];
            return {
                gridExists: !!grid,
                count: items.length,
                hasToday: Array.from(items).some(m => m.classList.contains('today'))
            };
        });
        
        if (milestones.gridExists && milestones.count > 0) {
            results.passed.push(`‚úÖ Meilensteine Grid mit ${milestones.count} Eintr√§gen`);
            if (milestones.hasToday) {
                results.passed.push('‚úÖ "Heute" Meilenstein vorhanden');
            }
        } else {
            results.failed.push('‚ùå Meilensteine nicht gefunden');
        }
        
        // 7. Performance Metriken
        console.log('\n‚ö° 7. Performance Metriken...');
        
        const metrics = await page.metrics();
        results.passed.push(`‚úÖ JS Heap: ${(metrics.JSHeapUsedSize / 1024 / 1024).toFixed(2)} MB`);
        results.passed.push(`‚úÖ DOM Nodes: ${metrics.Nodes}`);
        
        // 8. Console Errors pr√ºfen
        console.log('\nüêõ 8. Pr√ºfe Console Errors...');
        
        const errors = consoleLogs.filter(log => log.type === 'error');
        if (errors.length === 0) {
            results.passed.push('‚úÖ Keine JavaScript Fehler');
        } else {
            errors.forEach(err => {
                results.failed.push(`‚ùå JS Error: ${err.text}`);
            });
        }
        
        if (pageErrors.length > 0) {
            pageErrors.forEach(err => {
                results.failed.push(`‚ùå Page Error: ${err}`);
            });
        }
        
    } catch (error) {
        results.failed.push(`‚ùå Test Error: ${error.message}`);
    } finally {
        await browser.close();
    }
    
    // Test Report ausgeben
    console.log('\n' + '='.repeat(60));
    console.log('üìä TEST REPORT - Eva & Yannik Website v4.0.0');
    console.log('='.repeat(60) + '\n');
    
    console.log(`‚úÖ Bestanden: ${results.passed.length}`);
    console.log(`‚ö†Ô∏è  Warnungen: ${results.warnings.length}`);
    console.log(`‚ùå Fehler: ${results.failed.length}`);
    
    console.log('\n‚úÖ BESTANDENE TESTS:');
    results.passed.forEach(test => console.log(`   ${test}`));
    
    if (results.warnings.length > 0) {
        console.log('\n‚ö†Ô∏è  WARNUNGEN:');
        results.warnings.forEach(test => console.log(`   ${test}`));
    }
    
    if (results.failed.length > 0) {
        console.log('\n‚ùå FEHLGESCHLAGENE TESTS:');
        results.failed.forEach(test => console.log(`   ${test}`));
    }
    
    // Gesamtbewertung
    console.log('\n' + '='.repeat(60));
    const score = (results.passed.length / (results.passed.length + results.failed.length) * 100).toFixed(1);
    console.log(`üéØ GESAMTBEWERTUNG: ${score}%`);
    
    if (score >= 90) {
        console.log('‚ú® Website ist PRODUCTION READY!');
    } else if (score >= 70) {
        console.log('‚ö†Ô∏è  Website funktioniert, hat aber noch Probleme');
    } else {
        console.log('‚ùå Website hat kritische Probleme');
    }
    
    console.log('='.repeat(60) + '\n');
    
    // Test-Datei speichern
    fs.writeFileSync('test-results.json', JSON.stringify({
        timestamp: new Date().toISOString(),
        score: parseFloat(score),
        results: results
    }, null, 2));
    
    console.log('üìÑ Detaillierte Ergebnisse in test-results.json gespeichert');
    console.log('üì∏ Screenshots im screenshots/ Ordner\n');
}

// Ensure screenshots directory exists
if (!fs.existsSync('screenshots')) {
    fs.mkdirSync('screenshots');
}

// Run the test
runComprehensiveTest().catch(console.error);